import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity, SafeAreaView, ActivityIndicator, Linking } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';

type FeedEntry = { title: string; published?: string | null; summary?: string; link?: string };

export default function DailyDevotionalScreen() {
  const insets = useSafeAreaInsets();
  const [loading, setLoading] = useState(false);
  const [entries, setEntries] = useState<FeedEntry[]>([]);
  const [error, setError] = useState<string | null>(null);

  const feedUrl = 'https://odb.org/feed/';

  const fetchFeed = async () => {
    setLoading(true);
    setError(null);
    try {
      // lazy require parser to avoid bundler-time node imports
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const { XMLParser } = require('fast-xml-parser');

      let res = await fetch(feedUrl);
      if (!res.ok) {
        // retry with a browser-like UA
        try { res = await fetch(feedUrl, { headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)' } }); } catch (e) {}
      }
      if (!res.ok) throw new Error(`HTTP ${res.status}`);

      const xml = await res.text();
      const parser = new XMLParser({ ignoreAttributes: false, attributeNamePrefix: '@_' });
      const json = parser.parse(xml as any);
      const items = json.rss?.channel?.item || json.feed?.entry || [];
      const arr = Array.isArray(items) ? items : [items];

      const parsed = arr.map((it: any) => {
        const title = (it.title && (typeof it.title === 'string' ? it.title : it.title._text || it.title['#text'])) || '';

        let link: string | undefined;
        if (it.link) {
          if (typeof it.link === 'string') link = it.link;
          else if (Array.isArray(it.link) && it.link.length) link = it.link[0]?.['@_href'] || it.link[0]?.href || it.link[0]?._text;
          else link = it.link._text || it.link['#text'] || it.link['@_href'] || it.link.href;
        }

        const summary = (it.description?._text || it.description || it.summary?._text || it.summary || it['content:encoded'] || it.content) || '';
        const pubRaw = it.pubDate?._text || it.pubDate || it.published?._text || it.published || it.updated?._text || it.updated || null;

        return { title: String(title).trim(), published: pubRaw ? String(pubRaw) : null, summary: String(summary || '').trim(), link } as FeedEntry;
      }).filter((x: any) => x.title || x.summary);

      setEntries(parsed.slice(0, 3));
    } catch (err: any) {
      setError('Unable to fetch devotionals. Please try again later.');
      setEntries([]);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => { fetchFeed(); }, []);

  // Decode HTML entities (numeric and common named) then strip tags
  const decodeHtml = (raw?: string) => {
    if (!raw) return '';
    try {
      let s = String(raw);
      // numeric entities: &#8216; etc.
      s = s.replace(/&#(\d+);/g, (_m, dec) => String.fromCharCode(Number(dec)));
      // hex numeric entities: &#x2019;
      s = s.replace(/&#x([0-9a-fA-F]+);/g, (_m, hex) => String.fromCharCode(parseInt(hex, 16)));
      const map: Record<string, string> = {
        '&nbsp;': ' ', '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"', '&apos;': "'",
        '&rsquo;': '\u2019', '&lsquo;': '\u2018', '&ndash;': '\u2013', '&mdash;': '\u2014', '&hellip;': '\u2026'
      };
      Object.keys(map).forEach(k => { s = s.split(k).join(map[k]); });
      return s;
    } catch (e) { return raw || ''; }
  };

  const cleanHtml = (s?: string) => {
    const decoded = decodeHtml(s);
    return decoded ? decoded.replace(/<[^>]+>/g, '').trim() : '';
  };

  const formatDate = (raw?: string | null) => {
    if (!raw) return '';
    try {
      const d = new Date(raw as string);
      if (isNaN(d.getTime())) return raw as string;
      return d.toLocaleDateString(undefined, { month: 'long', day: 'numeric', year: 'numeric' });
    } catch (e) {
      return raw as string;
    }
  };

  return (
    <SafeAreaView style={[styles.container, { paddingTop: insets.top }]}> 
      <View style={styles.headerRow}>
        <View style={styles.headerLeft}>
          <Text style={styles.title}>Daily Devotional</Text>
          <Text style={styles.subtitle}>Our Daily Bread â€” latest reflections</Text>
        </View>
        <TouchableOpacity onPress={() => fetchFeed()} style={styles.refreshButton} accessibilityLabel="Refresh devotionals">
          <Ionicons name="refresh" size={20} color="#fff" />
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.content} contentContainerStyle={{ paddingBottom: 40 }} showsVerticalScrollIndicator={false}>
        {loading && <ActivityIndicator color="#6366f1" style={{ marginTop: 20 }} />}
        {!loading && error && <Text style={styles.errorText}>{error}</Text>}

        {!loading && !error && entries.length === 0 && (
          <View style={styles.emptyBox}><Text style={styles.emptyText}>No devotionals found.</Text></View>
        )}

        {entries.map((e, i) => (
          <TouchableOpacity key={String(e.link ?? i)} activeOpacity={0.92} style={styles.card} onPress={() => { try { if (e.link) Linking.openURL(e.link); } catch {} }}>
            <View style={styles.cardHeader}>
              <Text style={styles.pub}>{formatDate(e.published)}</Text>
            </View>
            <Text style={styles.passage} numberOfLines={2}>{e.title}</Text>
            {e.summary ? <Text style={styles.ref} numberOfLines={4}>{cleanHtml(e.summary)}</Text> : null}
            <View style={styles.cardFooter}>
              <TouchableOpacity style={styles.readMore} onPress={() => { try { if (e.link) Linking.openURL(e.link); } catch {} }}>
                <Text style={styles.readMoreText}>Read more</Text>
              </TouchableOpacity>
            </View>
          </TouchableOpacity>
        ))}

      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff' },
  header: { paddingHorizontal: 20, paddingVertical: 16, borderBottomWidth: 1, borderBottomColor: '#eee', flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' },
  title: { fontSize: 20, fontWeight: '600' },
  content: { flex: 1, paddingHorizontal: 20, paddingVertical: 16 },
  card: { backgroundColor: '#fafafa', padding: 16, borderRadius: 8, marginBottom: 20 },
  pub: { color: '#666', fontSize: 12, marginBottom: 8 },
  passage: { fontSize: 18, fontWeight: '700', marginBottom: 8 },
  ref: { fontSize: 15, color: '#333', lineHeight: 22, marginBottom: 8 },
  link: { color: '#2563eb', marginTop: 8 }
  ,
  headerRow: { paddingHorizontal: 20, paddingVertical: 16, flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', backgroundColor: '#0b1226' },
  headerLeft: { flexDirection: 'column' },
  subtitle: { color: '#9ca3af', fontSize: 13, marginTop: 2 },
  refreshButton: { backgroundColor: '#6366f1', padding: 10, borderRadius: 10 },
  errorText: { color: '#ef4444', marginTop: 12, paddingHorizontal: 20 },
  emptyBox: { backgroundColor: '#f8fafc', padding: 16, borderRadius: 12, marginTop: 12 },
  emptyText: { color: '#6b7280' },
  cardHeader: { marginBottom: 8 },
  cardFooter: { marginTop: 10, flexDirection: 'row', justifyContent: 'flex-end' },
  readMore: { backgroundColor: '#111827', paddingHorizontal: 12, paddingVertical: 8, borderRadius: 8 },
  readMoreText: { color: '#93c5fd', fontWeight: '700' }
});
